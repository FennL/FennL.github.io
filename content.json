{"meta":{"title":"Argonaut's Blog","subtitle":"","description":"","author":"FennL","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-07-10T13:49:29.000Z","updated":"2022-07-10T14:16:24.532Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"404","date":"2022-07-10T13:54:09.000Z","updated":"2022-07-10T13:54:52.250Z","comments":true,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"tags","date":"2022-07-10T13:47:45.000Z","updated":"2022-07-10T14:16:02.882Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"React易错点思考","slug":"React易错点思考","date":"2022-07-31T04:00:00.000Z","updated":"2022-08-03T16:39:31.100Z","comments":true,"path":"2022/07/31/React易错点思考/","link":"","permalink":"http://example.com/2022/07/31/React%E6%98%93%E9%94%99%E7%82%B9%E6%80%9D%E8%80%83/","excerpt":"","text":"React易错点思考// 入口文件 index.jsimport ReactDOM from &#x27;react-dom&#x27;// ReactDOM.render(组件名称，要注入的元素)ReactDOM.render(&lt;h1&gt;&lt;/h1&gt;,document.getElementId(&#x27;root&#x27;)) state的完整写法class Person extends Component&#123; constructor(props)&#123; super(props); this.state = &#123; num:1; &#125; &#125; render()&#123; return; &#125;&#125; // 完整写法中的state是要写在构造器中// 一般的省略写法class Person extends Component&#123; state = &#123; num : 1 &#125; render( return; )&#125; this的作用范围在类组件里 &lt;button onClick=&#123;this.B&#125;&gt;&lt;/button&gt;class A &#123; construct()&#123; // this -&gt; A this.B = this.B.bind(this) // 解决方法 &#125; render( // this -&gt; A ) B()&#123; // 这里的方法不在A属性上挂载，而是在A的原型对象上挂载，供A使用 // 严格模式下 this -&gt; window // 非严格模式下 this -&gt; undefined // 问题来了：这里想要使用 A对象 的话就不能直接使用this了 &#125;&#125;// 点击按钮，B方法只是赋值给onClick，实际调用B方法的并不是A对象，而是外层window/undefined【严格模式】 类组件的含义以及使用class Weather extends React.Component&#123; // 1.构造器 constructor(props)&#123; super(props); this.state = &#123;isHot:false,wind:&#x27;微风&#x27;&#125; this.changeWeather = this.changeWeather.bind(this); &#125; // 2.渲染 往往需要调用初始state进行展示 render()&#123; const &#123;isHot,wind &#125; = this.state; return &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天天气很&#123;isHot?&#x27;炎热&#x27;:&#x27;凉爽&#x27;&#125;,&#123;wind&#125;&lt;/h1&gt; &#125; // 3.事件函数 往往对state进行set changeWeather()&#123; const isHot = this.state.isHot; this.setState(&#123;isHot:isHot&#125;); &#125;&#125; 类组件的简写形式 省略构造器 原理是类中直接写赋值语句，属性直接会挂载在对象上，而不再是是原型 class Weather extends React.Component&#123; // 初始化 state = &#123; isHot:false, wind:&#x27;微风&#x27; &#125;; render()&#123; const &#123;isHot,wind &#125; = this.state; return &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;今天天气很&#123;isHot?&#x27;炎热&#x27;:&#x27;凉爽&#x27;&#125;,&#123;wind&#125;&lt;/h1&gt; &#125; // 自定义方法 change = ()=&gt;&#123; const isHot = this.state.isHot; this.setState(&#123;isHot:isHot&#125;); &#125;&#125; 箭头函数没有自己的this，如果用到this的话往往指的是外层的 React中的展开表达式// 1.函数传不定个数参数function sum (...number)&#123; &#125; // 2.构造新对象展开场景const p = &#123;name:&#x27;tom&#x27;,age:18&#125;&lt;Person &#123;...p&#125;/&gt; // React中可以展开对象 但只可以用在标签中使用！！ 这个通用场景太差了// 原生React不可以展开对象console.log(...p) // 报错// 3.修改对象属性let person3 = &#123;...person,name:&#x27;java&#x27;,address:&#x27;shannxi&#x27;&#125; props对标签属性进行限制React16需要手动引入props-types来进行书写 class Person extends React.Component&#123;&#125;&lt;Person name=&#x27;tom&#x27; age=&#123;18&#125; sex=&quot;男&quot;/&gt;// 可以限制属性类型Person.propTypes = &#123; name:PropsType.string.isRequired, sex:PropsType.string, age:PropsType.number&#125;Person.defaultType = &#123; sex:&quot;女&quot;, age:20&#125;=========================================class Person extends React.Component&#123; static propType = &#123;&#125;; // 属性加到类上，不是加到实例对象上 static defaultType = &#123;&#125;;&#125; refs属性字符串类型的ref给组件添加ref属性，取代原生js中的id。之后拿到标签对应的真实DOM可以直接使用this.refs.input，而不用再documentById来拿到 showData = ()=&gt;&#123; const &#123;input1&#125; = this.refs; // 可以这样拿到真实DOM input1.value &#125;&lt;input ref=&quot;input1&quot;/&gt;&lt;button onClick=&#123;this.showData&#125;&gt;&lt;/button&gt;=======================================================showData = ()=&gt;&#123; ddocumentByID(&#x27;input1&#x27;) input1.value &#125;&lt;input id=&quot;input1&quot;/&gt;&lt;button onClick=&#123;this.showData&#125;&gt;&lt;/button&gt; 字符串ref已废弃 匿名函数优点：节省内存空间,调用完临时对象立即释放 回调类型的ref属性&lt;input ref=&#123;(a)=&gt;&#123;console.log(a)&#125;&#125;/&gt;=========================================class Demo extends React.Component&#123; render()&#123; return( &lt;input ref=&#123;(currentNode)=&gt;&#123;this.input1=currentNode&#125;&#125;/&gt; //将当前DOM挂载在当前组件对象的属性上 ) &#125;&#125; 回调函数的定义：自己定义的，但不是自己调用的，这里只是自己定义的函数，是定义的，并不是调用的。 通过输出可以发现，这里的a其实是当前所属的DOM节点","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"Position详解","slug":"Position详解","date":"2022-07-26T04:00:00.000Z","updated":"2022-07-26T11:56:25.488Z","comments":true,"path":"2022/07/26/Position详解/","link":"","permalink":"http://example.com/2022/07/26/Position%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"Position详解static默认，没有定位。不会受到top、bottom、left、right的影响。 relative”元神出窍“，元神会相对于实体移动，方向可以是向上、向下、向左、向右来设置 absolute脱离正常的文档流，会浮出来，独立出来 fixed脱离文档流，并且会随着滚动条的滚动而滚动","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"代理和拦截器","slug":"代理和拦截器","date":"2022-07-26T04:00:00.000Z","updated":"2022-07-26T14:14:59.366Z","comments":true,"path":"2022/07/26/代理和拦截器/","link":"","permalink":"http://example.com/2022/07/26/%E4%BB%A3%E7%90%86%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/","excerpt":"","text":"前端本地开发代理配置因为同源因素，前端开发过程中往往需要代理，实际上生产的时候不需要代理，后端用nginx同样可以处理跨域问题。 Vue框架中可以在vue.config.js中的proxy属性中更改配置;webpack也可以在setProxy.js文件中修改proxy属性 场景：本地开发http://localhost发往http://www.vue.com/api/v1/topics发生的跨域问题 // vue.config.jsdevServer:&#123; proxy:&#123; &#x27;/api&#x27;:&#123; // /api表示请求中/api开头的请求拦截 target:&#x27;http://www.vue.com/api&#x27;, // 这里的域名可以带路径，也可以不带路径，对应两种方案 changeOrigin:true, pathRewrite:&#123; &#x27;^/api&#x27;:&#x27;&#x27; &#125; &#125; &#125;&#125;// request.jsaxios.get(&#x27;api/v1/topic&#x27;)==========================================================================// vue.config.jsdevServer:&#123; proxy:&#123; &#x27;/api&#x27;:&#123; target:&#x27;http://www.vue.com.&#x27;, // 不带路径 changeOrigin:true, // pathRewrite:&#123; // 不需要对路径重写。因为拼接之后只剩下一个/api/ // &#x27;^/api&#x27;:&#x27;&#x27; // &#125; &#125; &#125;&#125;// request.jsaxios.get(&#x27;api/v1/topic&#x27;) 可以设置多个代理 拦截器https://www.bilibili.com/index/ding.json 本地向这个链接发送请求 先配置跨域。将所有请求导向代理中的目标地址 创建axios实例以及对应的响应拦截器，请求拦截器 axios.interceptors.request.use(config =&gt;&#123; config.headers.Authorization = window.sessionStorage.getItem(&#x27;token &#x27;)&#125;) 使用axios实例进行正确发送","categories":[],"tags":[{"name":"axios","slug":"axios","permalink":"http://example.com/tags/axios/"},{"name":"代理","slug":"代理","permalink":"http://example.com/tags/%E4%BB%A3%E7%90%86/"},{"name":"拦截器","slug":"拦截器","permalink":"http://example.com/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"}]},{"title":"React配置代理解决跨域问题","slug":"React配置代理解决跨域问题","date":"2022-07-21T04:00:00.000Z","updated":"2022-07-21T17:03:41.446Z","comments":true,"path":"2022/07/21/React配置代理解决跨域问题/","link":"","permalink":"http://example.com/2022/07/21/React%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"React配置代理解决跨域问题跨域问题比较常见，而且几乎是必须解决的问题 比如本地localhost:3000是前端，后端localhost:5000是后端。直接通过ajax或者axios访问的话会被ajax引擎拦截，也就是前端实际就给拦截。但倘若使用代理的话，由于代理服务器没有ajax引擎拦截，所以可以发送通过。从而解决跨域问题 两种方法可以解决。 Package.json添加配置 &quot;proxy&quot;:&quot;https://localhost:5000&quot; 好用，但是只能指向一个代理地址 使用http-proxy-middleware模块解决 const proxy = require(&quot;http-proxy-middleware&quot;)module.exports = function(app) &#123; app.use( proxy(&#x27;/api1&#x27;,&#123; target:&quot;http://localhost:5000&quot;, changeOrigin:true, pathRewite:&#123;&#x27;^/api1&#x27;:&#x27;&#x27;&#125; &#125;) )&#125; 请求https://localhost:3000/api1/student,proxy里的api1匹配到请求地址3000后的api1,就把请求转向了target地址，又因为pathRewrite去换了api1，最终实际请求的地址是https://localhost:5000/student","categories":[],"tags":[{"name":"代理,react,前端","slug":"代理-react-前端","permalink":"http://example.com/tags/%E4%BB%A3%E7%90%86-react-%E5%89%8D%E7%AB%AF/"}]},{"title":"webpack总结","slug":"Webpack总结","date":"2022-07-21T04:00:00.000Z","updated":"2022-07-20T17:06:46.772Z","comments":true,"path":"2022/07/21/Webpack总结/","link":"","permalink":"http://example.com/2022/07/21/Webpack%E6%80%BB%E7%BB%93/","excerpt":"","text":"Webpack前端详解常见前端打包工具 Webpack、Parcel、Rollup 安装模块npm i webpack webpack-cli --save-dev// 全局安装webpack 在/opt/homebrew/webpack文件夹 可以使用which webpack来找 npm i -g webpack webpack-cli 安装完成以后，模块会出现在node_modules/bin文件夹下 这个文件夹下的文件可以使用npx或者yarn命令运行起来 运行webpacknpx webpack Webpack会默认从src/index.js文件开始打包，会把所有用到的模块打包在一起 Webpack4以后的版本支持零配置方式启动打包。从index.js文件开始找，找到两个js文件，并打包在/dist/main.js中 之后在HTML中就可以这样写 &lt;script src=&quot;dist/main.js&quot;&gt;&lt;/script&gt; // 里面没有export这种代码了不打包编译的话&lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt; 修改webpack默认配置默认配置无法满足我们的项目需求，需要对webpack进行个性化定制 新建webpack.config.js，在这里面写，名字不能变。这个文件运行在node.js环境中。 // ./webpack.config.jsconst path = require(&quot;path&quot;)module.exports=&#123; entry: &#x27;./src/main.js&#x27; // 指定项目的启动入口 不再是index.js output:&#123; filename:&quot;bundle.js&quot;, // 输出文件名称 path:path.join(__dirname,&#x27;output&#x27;) // 输出文件路径&#125;&#125; 可以直接使用node.js内置模块或者导入第三方的包！！！ 让配置文件支持只能提示 vscode是根据类型做出提示判断，webpack配置文件中的js往往没有显式地类型说明，可以使用webpack中的Configuration来做js的注释，表明该对象的类型，从而达到只能提示的目的 import &#123;Configuration&#125; from &quot;webpack&quot;/*@type &#123;Configuration&#125;*/const config = &#123; entry:&#x27;./src/index.js&#x27; output: &#123; filename:&quot;bundle.js&quot; path: path.join(__dirname,&#x27;output&#x27;)&#125;&#125; webpack工作模式有生产模式、开发模式、none模式 修改webpack工作模式有两种方式： 命令行CLI中 --mode参数传递 webpack配置文件中设置mode属性 加载器Loaderwebpack默认内置了js代码的加载器，将js代码打包成bundule.js.要想打包别的文件，就需要安装对应资源的Loader到项目中 npm i css-loader --save-dev 加载器Loader配置 module.exports=&#123; entry: &#x27;./src/main.css&#x27; // 不再是js 而是css output:&#123; filename:&quot;bundle.js&quot;, path:path.join(__dirname,&#x27;output&#x27;) &#125; module:&#123; rules:[ &#123; test: /\\.css$/, // 根据文件名称决定是否使用这个loader use: [&#x27;style-loader&#x27;,&#x27;css-loader&#x27;] // 指定loader &#125; ] &#125;&#125;","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"}]},{"title":"前端`axios`接口的封装","slug":"前端axios接口的封装","date":"2022-07-21T04:00:00.000Z","updated":"2022-07-26T14:14:59.259Z","comments":true,"path":"2022/07/21/前端axios接口的封装/","link":"","permalink":"http://example.com/2022/07/21/%E5%89%8D%E7%AB%AFaxios%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B0%81%E8%A3%85/","excerpt":"","text":"前端axios接口的封装 创建src/utils/request.js 写普通的前端js代码使用ES6,若是写node.js(尤其写配置文件)则使用commonJS语法 封装接口的公共部分 import axios from &#x27;axios&#x27;const request = axios.create(&#123; baseURL:&quot;http://localhost:3000&quot;, timeout: 5000&#125;)export default request 这段代码的封装结果就是得到了一个新的request函数,以后使用axios发送请求的时候就不会使用方法axios而是使用专用封装得到的request方法 实际发送请求使用 import request from &#x27;./utils/request&#x27;request(&#123; method:&quot;GET&quot;, url: &quot;/api/v4&quot;, params: &#123;username:&quot;argo&quot;,password: &quot;64172364&quot;&#125;&#125;) 可以将多个这种request写在一个文件里，这个文件吸引了专门的axios请求操作，其他文件使用的时候来这个文件直接调用即可。等于是继续封装 新建api/product.js // product.jsexport function getProduct(id)&#123; return request(&#123; method:&quot;GET&quot;, url : `/product/$&#123;id&#125;` &#125;)&#125;export function updateProduct(id,data)&#123; return request(&#123; method:&quot;PUT&quot;, url : `/product/$&#123;id&#125;`, data, &#125;)&#125;export function putProduct(id)&#123; return request(&#123; method:&quot;GET&quot;, url : `/product`, params:&#123; id:123 &#125; &#125;)&#125; 还可以继续深层封装 新建api/index.js import product from &quot;./product.js&quot;import xxx from &quot;./xxx.js&quot;export default&#123; product, xxx&#125; 再把整个api所有对象挂载到初始原型上，以方便this调用。Vue的话就是Vue.prototype.$api = api","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"axios","slug":"axios","permalink":"http://example.com/tags/axios/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"钩子Hook的作用","slug":"钩子Hook的作用","date":"2022-07-18T03:00:00.000Z","updated":"2022-07-18T03:30:15.331Z","comments":true,"path":"2022/07/18/钩子Hook的作用/","link":"","permalink":"http://example.com/2022/07/18/%E9%92%A9%E5%AD%90Hook%E7%9A%84%E4%BD%9C%E7%94%A8/","excerpt":"","text":"什么是钩子HooksReact组件分为类组件和函数组件，函数组件的API一般叫做钩子HooksAPI,Facebook官方目前也在大力鼓励使用函数组件，因为其相对更高的效率。所以今天来谈一谈函数组件中常见的钩子函数 纯函数与非纯函数函数组件的目的是返回组件的HTML代码，这种只进行构建HTML代码相关的函数叫做纯函数；其他含有与HMTL代码构建无关函数的 则是非纯函数，这些非相关函数也叫“副效应” 钩子就是为函数组件引入副效应的函数 常见钩子Hooks均是由react框架提供，使用时从import &#123;useState&#125; from &#39;react&#39;引入即可 专用钩子 useState()：保存状态 useContext()：保存上下文 useRef():保存引用 …… 通用钩子 useEffect() 找不到对应钩子就可以用它 useEffect用法每渲染一次，useEffect执行一次 import React,&#123;useEffect&#125; from &quot;react&quot;function Welcome(props)&#123; useEffect(()=&gt;&#123; document.title = &quot;加载完成&quot; &#125;) return &lt;h1&gt;HelloWorld&lt;/h1&gt;&#125; 第二个参数：一个数组。是函数渲染的依赖项，只有第二个参数发生变化，才会执行第一个参数里的函数。避免次次渲染都执行 import React,&#123;useEffect&#125; from &quot;react&quot;function Welcome(props)&#123; useEffect(()=&gt;&#123; document.title = &quot;加载完成&quot; &#125;,[props.name]) return &lt;h1&gt;HelloWorld&lt;/h1&gt;&#125; 如果第二个参数是空数组，表明只会在第一次渲染的时候执行一次，后面渲染不会执行 useEffect()&#123; ()=&gt;&#123; initLogin &#125;,[]&#125; 常见用途 获取数据 改变DOM 输出日志 事件监听或订阅","categories":[],"tags":[]},{"title":"函数组件和类组件","slug":"函数组件和类组件","date":"2022-07-17T14:10:01.556Z","updated":"2022-07-17T16:41:06.163Z","comments":true,"path":"2022/07/17/函数组件和类组件/","link":"","permalink":"http://example.com/2022/07/17/%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%92%8C%E7%B1%BB%E7%BB%84%E4%BB%B6/","excerpt":"","text":"函数组件和类组件函数组件实现函数组件最简单的方法就是编写Javascript函数 function Welcome(props)&#123; return &lt;h1&gt;Hello,&#123;props.name&#125;&lt;h1&gt;&#125; 在别的地方使用函数组件的方法:&lt;Welcome name=&quot;fenn&quot;/&gt; 类组件除了函数组件，还有ES6提供的class定义组件： class Welcome extends React.Component&#123; render()&#123; return &lt;h1&gt;Hello,&#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125; 使用方法一样，&lt;Welcome name=&quot;fenn&quot;/&gt; 共同点： 两种组件都无法自己修改自己的props 两种组件都是单向数据流，改变了父组件的属性，子组件的视图也会更新 props是外界传过来的，自己无法修改；state是自己本身的，自己可以修改，组件的props和state改变都会更新视图 区别： 函数组件性能更高，没有实体化过程 类组件和函数组件使用props&amp;state props: props是上层组件传递该层的数据接口，在子组件中只读 类组件中读取:this.props.xxx;函数组件中读取:props.xxx class Father extends React.Component&#123; render()&#123; return ( &lt;div&gt; 我是父亲 &lt;Son message = &quot;我是儿子&quot;/&gt; &lt;/div&gt; ) &#125;&#125;const Son = props =&gt; &#123; return ( &lt;div&gt; &#123;props.message&#125; &lt;/div&gt; )&#125; state 类组件读取state:this.state,写入this.setState或者this.setState(state=&gt;&#123;return &#123;n:state.n+1&#125;&#125;),推荐后者 add()&#123; this.setstate(&#123;n:this.state.n+1&#125;); this.setstate(state=&gt;&#123; return &#123;n:state.n+1&#125; &#125;)&#125; 函数组件用usestate返回数组，第一项读，第二项写，仍然没有this const Son = () =&gt;&#123; const [stateNum,stateSet] = React.useState(0); // 0是stateNum初始 return ( &lt;div&gt; 现在的state数量是:&#123;stateNum&#125; &lt;button onClick=&#123;()=&gt;&#123;stateSet(n+1)&#125;&#125;&gt;+1&lt;/button&gt; &lt;/div&gt; )&#125; setstate异步更新React并不像Vue是数据响应式，所以要更新UI，要使用setState，值得注意的是setstate是异步更新，所以UI更新也并不是立即变化，具体来说，多次状态修改会放在队列中，为了考虑性能，会将多次setState状态修改计算出最终结果后，只进行一次渲染。props的更新也是异步的 this指向this指向是一个老生常谈的问题，再谈谈吧 react中的类组件中有三处this指向的是当前实例化对象（当前组件本身） 构造函数 结论好理解，构造函数中this指向当前组件。这里谈一下new运算符：先产生一个对象&#123;&#125;和一个指针this,this指向&#123;&#125;;运行构造函数 动态添加属性&#123;&#125;.name=&quot;fenn&quot;,&#123;&#125;.age=3，最后将对象赋值给Dog // 早期function创建对象function Animal(nanme,age)&#123; this.name = name this.age = age&#125;Animal.prototype.say = function()&#123; console.log(this.name)&#125;const Dog = new Animal(&quot;dog&quot;,3)Dog.say() render函数 其他的生命周期函数 当this指向发生不清楚的时候，两种方案 this.x = this.x.bind(this)//箭头函数","categories":[],"tags":[]},{"title":"Location对象和useLocaton函数","slug":"Location和useLocation","date":"2022-07-17T04:00:00.000Z","updated":"2022-07-26T14:14:59.202Z","comments":true,"path":"2022/07/17/Location和useLocation/","link":"","permalink":"http://example.com/2022/07/17/Location%E5%92%8CuseLocation/","excerpt":"","text":"Location对象Location对象表示当前URL的信息，是window对象的一部分，准确来说是window对象的一个属性，可以通过window.location来访问 hash：可读写#后的URL host:可读写主机名和当前URL端口号 hostname:可读写主机名 href:可读写完整的URL port:读写端口号 protocal:读写当前URL协议 search:读写从?开始的URL useLocation返回当前URL的location对象。每当URL发生变化都会返回一个新的location对象 history对象访问过的URL的信息。 length:访问过的URL列表长度 back():后退 forward():前进 go()：兼具前进后退的功能 useHistory返回history对象。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-07-09T17:08:00.000Z","updated":"2022-07-10T14:52:07.393Z","comments":true,"path":"2022/07/10/hello-world/","link":"","permalink":"http://example.com/2022/07/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]},{"title":"Hexo的使用","slug":"Hexo的使用","date":"2022-07-09T17:07:55.000Z","updated":"2022-07-10T14:50:57.108Z","comments":true,"path":"2022/07/10/Hexo的使用/","link":"","permalink":"http://example.com/2022/07/10/Hexo%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Hexo使用前提，需要node.js环境 安装Hexosudo npm install -g hexo-cli 初始化博客项目hexo init blog ## 默认在桌面打开终端 进行本地预览依次输入下面命令 hexo new test_my_site ## 新建文章在文件夹项目打开终端或者使用cd命令切换进入文件夹hexo g ## 生成页面hexo s ## 启动预览 浏览器中访问http://localhost:4000可以观察是否启动成功。 Tips:如果出现localhost拒绝了我们的连接请求可能是端口被占用的原因，手动切换hexo端口hexo server -p 5000 Hexo命令hexo d ## hexo deployhexo server # 监视文件变动 自动更新hexo server -p 5000 # 切换端口hexo server -i 192.168.1.1 # 自定义ip 推送到GitHub在推送之前，需要对站点进行设置以让更多的人访问；对主题进行设置，选择自己喜欢的主题 打开站点配置文件_config.yml 其实就是给hexo d命令做相应配置 deploy: type: git repo: https://github.com/FennL/FennL.github.io.git branch: master 在这个项目中安装git部署插件:npm install hexo-deployer-git --save 再重新启动 hexo cleanhexo ghexo d 设置主题一般是需要设置主题，因为自带的主题是在是太简陋。 主题放在/Blog/themes下: 下载next主题：git clone https://github.com/iissnan/hexo-theme-next themes/next 站点修改配置: theme:next 主题修改配置： # Scheme# scheme:Muse# scheme:Mist# scheme:Pisces 选一种scheme:Pisces 发布文章进入博客所在目录 hexo new &quot;My New Post&quot; source文件夹会出现每一篇文章，写完文章之后运行 hexo ghexo d 将文章渲染并发布 遇到的坑 启动服务出现一下乱码 “ &#123;% extends ‘_layout.swig‘ %&#125; &#123;% import ‘_macro/post.swig‘ as post_template %&#125; hexo5.0之后缺少swig插件，需要自己安装 npm i hexo-renderer-swig hexo d出现报错 使用git仓库的ssh地址，不要使用https地址","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}],"categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"axios","slug":"axios","permalink":"http://example.com/tags/axios/"},{"name":"代理","slug":"代理","permalink":"http://example.com/tags/%E4%BB%A3%E7%90%86/"},{"name":"拦截器","slug":"拦截器","permalink":"http://example.com/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"name":"代理,react,前端","slug":"代理-react-前端","permalink":"http://example.com/tags/%E4%BB%A3%E7%90%86-react-%E5%89%8D%E7%AB%AF/"},{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}