{"meta":{"title":"Argonaut's Blog","subtitle":"","description":"","author":"FennL","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2022-07-10T13:54:09.000Z","updated":"2022-07-10T13:54:52.250Z","comments":true,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"categories","date":"2022-07-10T13:49:29.000Z","updated":"2022-07-10T14:16:24.532Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-07-10T13:47:45.000Z","updated":"2022-07-10T14:16:02.882Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"webpack总结","slug":"Webpack总结","date":"2022-07-21T04:00:00.000Z","updated":"2022-07-20T17:06:46.772Z","comments":true,"path":"2022/07/21/Webpack总结/","link":"","permalink":"http://example.com/2022/07/21/Webpack%E6%80%BB%E7%BB%93/","excerpt":"","text":"Webpack前端详解常见前端打包工具 Webpack、Parcel、Rollup 安装模块npm i webpack webpack-cli --save-dev// 全局安装webpack 在/opt/homebrew/webpack文件夹 可以使用which webpack来找 npm i -g webpack webpack-cli 安装完成以后，模块会出现在node_modules/bin文件夹下 这个文件夹下的文件可以使用npx或者yarn命令运行起来 运行webpacknpx webpack Webpack会默认从src/index.js文件开始打包，会把所有用到的模块打包在一起 Webpack4以后的版本支持零配置方式启动打包。从index.js文件开始找，找到两个js文件，并打包在/dist/main.js中 之后在HTML中就可以这样写 &lt;script src=&quot;dist/main.js&quot;&gt;&lt;/script&gt; // 里面没有export这种代码了不打包编译的话&lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt; 修改webpack默认配置默认配置无法满足我们的项目需求，需要对webpack进行个性化定制 新建webpack.config.js，在这里面写，名字不能变。这个文件运行在node.js环境中。 // ./webpack.config.jsconst path = require(&quot;path&quot;)module.exports=&#123; entry: &#x27;./src/main.js&#x27; // 指定项目的启动入口 不再是index.js output:&#123; filename:&quot;bundle.js&quot;, // 输出文件名称 path:path.join(__dirname,&#x27;output&#x27;) // 输出文件路径&#125;&#125; 可以直接使用node.js内置模块或者导入第三方的包！！！ 让配置文件支持只能提示 vscode是根据类型做出提示判断，webpack配置文件中的js往往没有显式地类型说明，可以使用webpack中的Configuration来做js的注释，表明该对象的类型，从而达到只能提示的目的 import &#123;Configuration&#125; from &quot;webpack&quot;/*@type &#123;Configuration&#125;*/const config = &#123; entry:&#x27;./src/index.js&#x27; output: &#123; filename:&quot;bundle.js&quot; path: path.join(__dirname,&#x27;output&#x27;)&#125;&#125; webpack工作模式有生产模式、开发模式、none模式 修改webpack工作模式有两种方式： 命令行CLI中 --mode参数传递 webpack配置文件中设置mode属性 加载器Loaderwebpack默认内置了js代码的加载器，将js代码打包成bundule.js.要想打包别的文件，就需要安装对应资源的Loader到项目中 npm i css-loader --save-dev 加载器Loader配置 module.exports=&#123; entry: &#x27;./src/main.css&#x27; // 不再是js 而是css output:&#123; filename:&quot;bundle.js&quot;, path:path.join(__dirname,&#x27;output&#x27;) &#125; module:&#123; rules:[ &#123; test: /\\.css$/, // 根据文件名称决定是否使用这个loader use: [&#x27;style-loader&#x27;,&#x27;css-loader&#x27;] // 指定loader &#125; ] &#125;&#125;","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"}]},{"title":"钩子Hook的作用","slug":"钩子Hook的作用","date":"2022-07-18T03:00:00.000Z","updated":"2022-07-18T03:30:15.331Z","comments":true,"path":"2022/07/18/钩子Hook的作用/","link":"","permalink":"http://example.com/2022/07/18/%E9%92%A9%E5%AD%90Hook%E7%9A%84%E4%BD%9C%E7%94%A8/","excerpt":"","text":"什么是钩子HooksReact组件分为类组件和函数组件，函数组件的API一般叫做钩子HooksAPI,Facebook官方目前也在大力鼓励使用函数组件，因为其相对更高的效率。所以今天来谈一谈函数组件中常见的钩子函数 纯函数与非纯函数函数组件的目的是返回组件的HTML代码，这种只进行构建HTML代码相关的函数叫做纯函数；其他含有与HMTL代码构建无关函数的 则是非纯函数，这些非相关函数也叫“副效应” 钩子就是为函数组件引入副效应的函数 常见钩子Hooks均是由react框架提供，使用时从import &#123;useState&#125; from &#39;react&#39;引入即可 专用钩子 useState()：保存状态 useContext()：保存上下文 useRef():保存引用 …… 通用钩子 useEffect() 找不到对应钩子就可以用它 useEffect用法每渲染一次，useEffect执行一次 import React,&#123;useEffect&#125; from &quot;react&quot;function Welcome(props)&#123; useEffect(()=&gt;&#123; document.title = &quot;加载完成&quot; &#125;) return &lt;h1&gt;HelloWorld&lt;/h1&gt;&#125; 第二个参数：一个数组。是函数渲染的依赖项，只有第二个参数发生变化，才会执行第一个参数里的函数。避免次次渲染都执行 import React,&#123;useEffect&#125; from &quot;react&quot;function Welcome(props)&#123; useEffect(()=&gt;&#123; document.title = &quot;加载完成&quot; &#125;,[props.name]) return &lt;h1&gt;HelloWorld&lt;/h1&gt;&#125; 如果第二个参数是空数组，表明只会在第一次渲染的时候执行一次，后面渲染不会执行 useEffect()&#123; ()=&gt;&#123; initLogin &#125;,[]&#125; 常见用途 获取数据 改变DOM 输出日志 事件监听或订阅","categories":[],"tags":[]},{"title":"函数组件和类组件","slug":"函数组件和类组件","date":"2022-07-17T14:10:01.556Z","updated":"2022-07-17T16:41:06.163Z","comments":true,"path":"2022/07/17/函数组件和类组件/","link":"","permalink":"http://example.com/2022/07/17/%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E5%92%8C%E7%B1%BB%E7%BB%84%E4%BB%B6/","excerpt":"","text":"函数组件和类组件函数组件实现函数组件最简单的方法就是编写Javascript函数 function Welcome(props)&#123; return &lt;h1&gt;Hello,&#123;props.name&#125;&lt;h1&gt;&#125; 在别的地方使用函数组件的方法:&lt;Welcome name=&quot;fenn&quot;/&gt; 类组件除了函数组件，还有ES6提供的class定义组件： class Welcome extends React.Component&#123; render()&#123; return &lt;h1&gt;Hello,&#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125; 使用方法一样，&lt;Welcome name=&quot;fenn&quot;/&gt; 共同点： 两种组件都无法自己修改自己的props 两种组件都是单向数据流，改变了父组件的属性，子组件的视图也会更新 props是外界传过来的，自己无法修改；state是自己本身的，自己可以修改，组件的props和state改变都会更新视图 区别： 函数组件性能更高，没有实体化过程 类组件和函数组件使用props&amp;state props: props是上层组件传递该层的数据接口，在子组件中只读 类组件中读取:this.props.xxx;函数组件中读取:props.xxx class Father extends React.Component&#123; render()&#123; return ( &lt;div&gt; 我是父亲 &lt;Son message = &quot;我是儿子&quot;/&gt; &lt;/div&gt; ) &#125;&#125;const Son = props =&gt; &#123; return ( &lt;div&gt; &#123;props.message&#125; &lt;/div&gt; )&#125; state 类组件读取state:this.state,写入this.setState或者this.setState(state=&gt;&#123;return &#123;n:state.n+1&#125;&#125;),推荐后者 add()&#123; this.setstate(&#123;n:this.state.n+1&#125;); this.setstate(state=&gt;&#123; return &#123;n:state.n+1&#125; &#125;)&#125; 函数组件用usestate返回数组，第一项读，第二项写，仍然没有this const Son = () =&gt;&#123; const [stateNum,stateSet] = React.useState(0); // 0是stateNum初始 return ( &lt;div&gt; 现在的state数量是:&#123;stateNum&#125; &lt;button onClick=&#123;()=&gt;&#123;stateSet(n+1)&#125;&#125;&gt;+1&lt;/button&gt; &lt;/div&gt; )&#125; setstate异步更新React并不像Vue是数据响应式，所以要更新UI，要使用setState，值得注意的是setstate是异步更新，所以UI更新也并不是立即变化，具体来说，多次状态修改会放在队列中，为了考虑性能，会将多次setState状态修改计算出最终结果后，只进行一次渲染。props的更新也是异步的 this指向this指向是一个老生常谈的问题，再谈谈吧 react中的类组件中有三处this指向的是当前实例化对象（当前组件本身） 构造函数 结论好理解，构造函数中this指向当前组件。这里谈一下new运算符：先产生一个对象&#123;&#125;和一个指针this,this指向&#123;&#125;;运行构造函数 动态添加属性&#123;&#125;.name=&quot;fenn&quot;,&#123;&#125;.age=3，最后将对象赋值给Dog // 早期function创建对象function Animal(nanme,age)&#123; this.name = name this.age = age&#125;Animal.prototype.say = function()&#123; console.log(this.name)&#125;const Dog = new Animal(&quot;dog&quot;,3)Dog.say() render函数 其他的生命周期函数 当this指向发生不清楚的时候，两种方案 this.x = this.x.bind(this)//箭头函数","categories":[],"tags":[]},{"title":"Location对象和useLocaton函数","slug":"Location和useLocation","date":"2022-07-17T04:00:00.000Z","updated":"2022-07-18T06:46:21.668Z","comments":true,"path":"2022/07/17/Location和useLocation/","link":"","permalink":"http://example.com/2022/07/17/Location%E5%92%8CuseLocation/","excerpt":"","text":"Location对象Location对象表示当前URL的信息，是window对象的一部分，准确来说是window对象的一个属性，可以通过window.location来访问 hash：可读写#后的URL host:可读写主机名和当前URL端口号 hostname:可读写主机名 href:可读写完整的URL port:读写端口号 protocal:读写当前URL协议 search:读写从?开始的URL useLocation返回当前URL的location对象。每当URL发生变化都会返回一个新的location对象 history对象访问过的URL的信息。 length:访问过的URL列表长度 back():后退 forward():前进 go()：兼具前进后退的功能 useHistory返回history对象。","categories":[],"tags":[{"name":"javascript,react,前端","slug":"javascript-react-前端","permalink":"http://example.com/tags/javascript-react-%E5%89%8D%E7%AB%AF/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-07-09T17:08:00.000Z","updated":"2022-07-10T14:52:07.393Z","comments":true,"path":"2022/07/10/hello-world/","link":"","permalink":"http://example.com/2022/07/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]},{"title":"Hexo的使用","slug":"Hexo的使用","date":"2022-07-09T17:07:55.000Z","updated":"2022-07-10T14:50:57.108Z","comments":true,"path":"2022/07/10/Hexo的使用/","link":"","permalink":"http://example.com/2022/07/10/Hexo%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Hexo使用前提，需要node.js环境 安装Hexosudo npm install -g hexo-cli 初始化博客项目hexo init blog ## 默认在桌面打开终端 进行本地预览依次输入下面命令 hexo new test_my_site ## 新建文章在文件夹项目打开终端或者使用cd命令切换进入文件夹hexo g ## 生成页面hexo s ## 启动预览 浏览器中访问http://localhost:4000可以观察是否启动成功。 Tips:如果出现localhost拒绝了我们的连接请求可能是端口被占用的原因，手动切换hexo端口hexo server -p 5000 Hexo命令hexo d ## hexo deployhexo server # 监视文件变动 自动更新hexo server -p 5000 # 切换端口hexo server -i 192.168.1.1 # 自定义ip 推送到GitHub在推送之前，需要对站点进行设置以让更多的人访问；对主题进行设置，选择自己喜欢的主题 打开站点配置文件_config.yml 其实就是给hexo d命令做相应配置 deploy: type: git repo: https://github.com/FennL/FennL.github.io.git branch: master 在这个项目中安装git部署插件:npm install hexo-deployer-git --save 再重新启动 hexo cleanhexo ghexo d 设置主题一般是需要设置主题，因为自带的主题是在是太简陋。 主题放在/Blog/themes下: 下载next主题：git clone https://github.com/iissnan/hexo-theme-next themes/next 站点修改配置: theme:next 主题修改配置： # Scheme# scheme:Muse# scheme:Mist# scheme:Pisces 选一种scheme:Pisces 发布文章进入博客所在目录 hexo new &quot;My New Post&quot; source文件夹会出现每一篇文章，写完文章之后运行 hexo ghexo d 将文章渲染并发布 遇到的坑 启动服务出现一下乱码 “ &#123;% extends ‘_layout.swig‘ %&#125; &#123;% import ‘_macro/post.swig‘ as post_template %&#125; hexo5.0之后缺少swig插件，需要自己安装 npm i hexo-renderer-swig hexo d出现报错 使用git仓库的ssh地址，不要使用https地址","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}],"categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"},{"name":"javascript,react,前端","slug":"javascript-react-前端","permalink":"http://example.com/tags/javascript-react-%E5%89%8D%E7%AB%AF/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}